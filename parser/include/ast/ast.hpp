#pragma once
#include <string>
#include <vector>
#include <memory>
#include <sstream>

#include "lexer/token.hpp"

namespace ast {

// using extend
inline namespace v_0_1 {

struct Node {
	virtual std::string token_literal() const noexcept = 0;
	virtual std::string to_string() const noexcept = 0;
	virtual ~Node() = default;
};

struct Statement: Node {};
using StmtPtr = std::unique_ptr<Statement>;

struct Expression: Node {};
using ExpressionPtr = std::unique_ptr<Expression>;

struct Program {
	std::vector<StmtPtr> statements;
	// std::vector<std::string> errors;
	std::string to_string() const noexcept
	{
		
		std::ostringstream out;
		for (const auto& s: statements) {
			out << s->to_string();
		}
		return out.str();
	}
};

// In some areas, Identifier does not generate values.
// But to stay easy, we use a same struct.
struct Identifier: Expression {
	token::Token token_;
	std::string value_;

	Identifier() = default;
	Identifier(token::Token t, std::string v):
		token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return value_;
	}
};
using IdentifierPtr = std::unique_ptr<Identifier>;

struct LetStmt : Statement {
	token::Token token_; // let token
	IdentifierPtr name_;
	// the value which generated by expression
	ExpressionPtr value_;

	// LetStat() = default;
	// LetStat(token::Token& token, Identifier* name, Expression* value = nullptr)
	//   :token_(token),
	//   name_(std::unique_ptr<Identifier>(name)),
	//   value_(std::unique_ptr<Expression>(value)) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}
	
	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << token_.literal << ' ' << name_->to_string() << " = ";
		if (value_)
			out << value_->to_string();
		out << ';';
		return out.str();
	}
};

struct ReturnStmt: Statement {
	token::Token token_; // return token
	ExpressionPtr return_value_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << token_.literal << ' ';
		if (return_value_)
			out << return_value_->to_string();
		out << ';';
		return out.str();
	}
};

struct ExpressionStmt: Statement {
	token::Token token_;
	ExpressionPtr expression_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return expression_ ? expression_->to_string() : "";
	}
	
};

struct IntegerLiteral: Expression {
	token::Token token_;
	std::int64_t value_;

	IntegerLiteral() = default;
	IntegerLiteral(token::Token t, std::int64_t v):
		token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return token_.literal;
	}
};

struct PrefixExpression: Expression {
	token::Token token_;
	std::string operator_;
	ExpressionPtr right_;

	PrefixExpression() = default;
	PrefixExpression(token::Token t, std::string op):
		token_(t), operator_(op) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << '(' << operator_ << right_->to_string() << ')';
		return out.str();
	}
};

struct InfixExpression: Expression {
	token::Token token_;
	ExpressionPtr left_;
	std::string operator_;
	ExpressionPtr right_;

	InfixExpression() = default;
	InfixExpression(token::Token t, std::string op, Expression* left):
		token_(t), operator_(op), left_(left) {}
	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << '(' << left_->to_string() << ' ' 
			<< operator_ << ' ' << right_->to_string() << ')';
		return out.str();
	}
};

struct Boolean: Expression {
	token::Token token_;
	bool value_;

	Boolean() = default;
	Boolean(token::Token t, bool v): token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return token_.literal;
	}
};

struct BlockStmt: Statement {
	token::Token token_;
	std::vector<StmtPtr> statements_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}
	
	std::string to_string() const noexcept override
	{
		
		std::ostringstream out;
		for (const auto& s: statements_) {
			out << s->to_string();
		}
		return out.str();
	}
};

using BlockStmtPtr = std::unique_ptr<BlockStmt>;

struct IfExpression: Expression {
	token::Token token_;
	ExpressionPtr cond_;
	BlockStmtPtr consequence_;
	BlockStmtPtr alternative_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << "if" << cond_->to_string() << ' ' << consequence_->to_string();
		if (alternative_) {
			out << " else " << alternative_->to_string();
		}
		return out.str();
	}
};

struct FunctionLiteral: Expression {
	using ParamType = Identifier;
	using Parameters = std::shared_ptr<std::vector<IdentifierPtr>>;
	using Body = std::shared_ptr<BlockStmt>;
	token::Token token_;
	Parameters parameters_;
	Body body_;

	FunctionLiteral() = default;
	FunctionLiteral(token::Token t, Parameters::element_type&& ps, BlockStmt* body):
		token_(t),
		parameters_(std::make_shared<typename Parameters::element_type>(std::move(ps))),
		body_(body) {}
	// FunctionLiteral(FunctionLiteral&& f):
	//   token_(f.token_), parameters_(std::move(f.parameters_)), body_(std::move(f.body_))
	// {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}



	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << token_.literal << '(';
		// join: BUG: size_t is unsigned
		if (parameters_ && !parameters_->empty()) {
			std::size_t n = parameters_->size() - 1;
			for (std::size_t i = 0; i < n; ++i) {
				out << (*parameters_)[i]->to_string() << ", ";
			}
			out << (*parameters_)[n]->to_string();
		}

		out << ") {";

		if (body_)
			out	<< body_->to_string();

		out << " }";
		return out.str();
	}
};

struct CallExpression: Expression {
	token::Token token_;
	ExpressionPtr fn_;
	using ArgType = Expression;
	using Arguments = std::vector<ExpressionPtr>;
	Arguments args_;

	CallExpression() = default;
	CallExpression(token::Token t, Expression* fn, Arguments&& args):
		token_(t), fn_(fn), args_(std::move(args)) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << fn_->to_string() << '(';
		int n = args_.size() - 1;
		for (int i = 0; i < n; ++i)
			out << args_[i]->to_string() << ", ";
		out << args_[n]->to_string() << ')';
		return out.str();
	}
};


struct StringLiteral: Expression {
	token::Token token_;
	std::string value_;

	StringLiteral() = default;
	StringLiteral(token::Token t, std::string const& v):
		token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return value_;
	}
};

struct ArrayLiteral: Expression {
	token::Token token_;
	using ElementType = Expression;
	// ??? Using shared_ptr for reference type?
	// Moreover, now ASSIGN is unsupported, so reference is meaningless.
	using Elements = std::vector<std::unique_ptr<ElementType>>;
	Elements elements_;

	ArrayLiteral() = default;
	ArrayLiteral(token::Token t, Elements&& elems):
		token_(t), elements_(std::move(elems)) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << '[';
		if (!elements_.empty()) {
			std::size_t n = elements_.size() - 1;
			for (std::size_t i = 0; i < n; ++i)
				out << elements_[i]->to_string() << ", ";
			out << elements_[n]->to_string();
		}
		out << ']';
		return out.str();
	}
};

struct IndexExpression: Expression {
	token::Token token_;
	ExpressionPtr left_;
	ExpressionPtr index_;

	IndexExpression() = default;
	IndexExpression(token::Token t, Expression* l, Expression* i):
		token_(t), left_(l), index_(i) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << "(" << left_->to_string() << "[" << index_->to_string() << "])";
		return out.str();
	}
};

struct HashTableLiteral: Expression {
	token::Token token_; // {
	using Pair = std::pair<ExpressionPtr, ExpressionPtr>;
	std::vector<Pair> pairs_;

	HashTableLiteral() = default;
	HashTableLiteral(token::Token t, std::vector<Pair>&& ps):
		token_(t), pairs_(std::move(ps)) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}
	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << '{';
		if (!pairs_.empty()) {
			std::size_t n = pairs_.size() - 1;
			for (std::size_t i = 0; i < n; ++i) {
				auto const& [k, v] = pairs_[i];
				out << k->to_string() << ": " << v->to_string() << ", ";
			}
			auto const& [k, v] = pairs_[n];
			out << k->to_string() << ": " << v->to_string();
		}
		out << '}';
		return out.str();
	}
};

} // namespace v_0_1
}
