#pragma once
#include <string>
#include <vector>
#include <memory>
#include <iostream>

#include "lexer/token.hpp"

namespace ast {

// using extend
inline namespace v_0_1 {

struct Node {
	virtual std::string token_literal() = 0;
	virtual ~Node() = default;
};

struct Statement: Node {
	virtual void statement_node() {}
	// virtual ~Statement() = default;
};
struct StmtDeleter {
	void operator()(Statement* s) const {
		std::cout << s << " is deleted\n";
		delete s;
	} 
};
using StmtPtr = std::unique_ptr<Statement, StmtDeleter>;

struct Expression: Node {
	virtual void expression_node() {}
};
using ExpressionPtr = std::unique_ptr<Expression>;

struct Program {
	std::vector<StmtPtr> statements;
	// std::vector<std::string> errors;
};

// In some areas, Identifier does not generate values.
// But to stay easy, we use a same struct.
struct Identifier: Expression {
	token::Token token;
	std::string value;

	Identifier() = default;
	Identifier(token::Token t, std::string v):
		token(t), value(v) {}


	std::string token_literal()
	{
		return token.literal;
	}
};
using IdentifierPtr = std::unique_ptr<Identifier>;

struct LetStmt : Statement {
	token::Token token_; // let token
	IdentifierPtr name_;
	// the value which generated by expression
	ExpressionPtr value_;

	// LetStat() = default;
	// LetStat(token::Token& token, Identifier* name, Expression* value = nullptr)
	//   :token_(token),
	//   name_(std::unique_ptr<Identifier>(name)),
	//   value_(std::unique_ptr<Expression>(value)) {}

	std::string token_literal()
	{
		return token_.literal;
	}
};

struct ReturnStmt: Statement {
	token::Token token_; // return token
	ExpressionPtr return_value_;

	std::string token_literal()
	{
		return token_.literal;
	}
};

struct ExpressionStmt: Statement {
	token::Token token_;
	ExpressionPtr expression_;

	std::string token_literal()
	{
		return token_.literal;
	}
};

} // namespace v_0_1
}
