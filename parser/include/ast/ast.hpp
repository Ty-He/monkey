#pragma once
#include <string>
#include <vector>
#include <memory>
#include <sstream>

#include "lexer/token.hpp"

namespace ast {

// using extend
inline namespace v_0_1 {

struct Node {
	virtual std::string token_literal() const noexcept = 0;
	virtual std::string to_string() const noexcept = 0;
	virtual ~Node() = default;
};

struct Statement: Node {};
using StmtPtr = std::unique_ptr<Statement>;

struct Expression: Node {};
using ExpressionPtr = std::unique_ptr<Expression>;

struct Program {
	std::vector<StmtPtr> statements;
	// std::vector<std::string> errors;
	std::string to_string() const noexcept
	{
		
		std::ostringstream out;
		for (const auto& s: statements) {
			out << s->to_string();
		}
		return out.str();
	}
};

// In some areas, Identifier does not generate values.
// But to stay easy, we use a same struct.
struct Identifier: Expression {
	token::Token token_;
	std::string value_;

	Identifier() = default;
	Identifier(token::Token t, std::string v):
		token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return value_;
	}
};
using IdentifierPtr = std::unique_ptr<Identifier>;

struct LetStmt : Statement {
	token::Token token_; // let token
	IdentifierPtr name_;
	// the value which generated by expression
	ExpressionPtr value_;

	// LetStat() = default;
	// LetStat(token::Token& token, Identifier* name, Expression* value = nullptr)
	//   :token_(token),
	//   name_(std::unique_ptr<Identifier>(name)),
	//   value_(std::unique_ptr<Expression>(value)) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}
	
	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << token_.literal << ' ' << name_->to_string() << " = ";
		if (value_)
			out << value_->to_string();
		out << ';';
		return out.str();
	}
};

struct ReturnStmt: Statement {
	token::Token token_; // return token
	ExpressionPtr return_value_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << token_.literal << ' ';
		if (return_value_)
			out << return_value_->to_string();
		out << ';';
		return out.str();
	}
};

struct ExpressionStmt: Statement {
	token::Token token_;
	ExpressionPtr expression_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return expression_ ? expression_->to_string() : "";
	}
	
};

struct IntegerLiteral: Expression {
	token::Token token_;
	std::int64_t value_;

	IntegerLiteral() = default;
	IntegerLiteral(token::Token t, std::int64_t v):
		token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return token_.literal;
	}
};

struct PrefixExpression: Expression {
	token::Token token_;
	std::string operator_;
	ExpressionPtr right_;

	PrefixExpression() = default;
	PrefixExpression(token::Token t, std::string op):
		token_(t), operator_(op) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << '(' << operator_ << right_->to_string() << ')';
		return out.str();
	}
};

struct InfixExpression: Expression {
	token::Token token_;
	ExpressionPtr left_;
	std::string operator_;
	ExpressionPtr right_;

	InfixExpression() = default;
	InfixExpression(token::Token t, std::string op, Expression* left):
		token_(t), operator_(op), left_(left) {}
	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << '(' << left_->to_string() << ' ' 
			<< operator_ << ' ' << right_->to_string() << ')';
		return out.str();
	}
};

struct Boolean: Expression {
	token::Token token_;
	bool value_;

	Boolean() = default;
	Boolean(token::Token t, bool v): token_(t), value_(v) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		return token_.literal;
	}
};

struct BlockStmt: Statement {
	token::Token token_;
	std::vector<StmtPtr> statements_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}
	
	std::string to_string() const noexcept override
	{
		
		std::ostringstream out;
		for (const auto& s: statements_) {
			out << s->to_string();
		}
		return out.str();
	}
};

using BlockStmtPtr = std::unique_ptr<BlockStmt>;

struct IfExpression: Expression {
	token::Token token_;
	ExpressionPtr cond_;
	BlockStmtPtr consequence_;
	BlockStmtPtr alternative_;

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << "if" << cond_->to_string() << ' ' << consequence_->to_string();
		if (alternative_) {
			out << " else " << alternative_->to_string();
		}
		return out.str();
	}
};

struct FunctionLiteral: Expression {
	using ParamType = Identifier;
	using Parameters = std::vector<IdentifierPtr>;
	token::Token token_;
	Parameters parameters_;
	BlockStmtPtr body_;

	FunctionLiteral() = default;
	FunctionLiteral(token::Token t, Parameters&& ps, BlockStmt* body):
		token_(t), parameters_(std::move(ps)), body_(body) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}



	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << token_.literal << '(';
		// join: BUG: size_t is unsigned
		if (!parameters_.empty()) {
			std::size_t n = parameters_.size() - 1;
			for (std::size_t i = 0; i < n; ++i) {
				out << parameters_[i]->to_string() << ", ";
			}
			out << parameters_[n]->to_string();
		}

		out << ") " << body_->to_string();

		return out.str();
	}
};

struct CallExpression: Expression {
	token::Token token_;
	ExpressionPtr fn_;
	using ArgType = Expression;
	using Arguments = std::vector<ExpressionPtr>;
	Arguments args_;

	CallExpression() = default;
	CallExpression(token::Token t, Expression* fn, Arguments&& args):
		token_(t), fn_(fn), args_(std::move(args)) {}

	std::string token_literal() const noexcept override
	{
		return token_.literal;
	}

	std::string to_string() const noexcept override
	{
		std::ostringstream out;
		out << fn_->to_string() << '(';
		int n = args_.size() - 1;
		for (int i = 0; i < n; ++i)
			out << args_[i]->to_string() << ", ";
		out << args_[n]->to_string() << ')';
		return out.str();
	}
};

} // namespace v_0_1
}
